 <html lang="en">
<head>
     <meta charset="UTF-8" />
     <meta name="viewport" content="width=device-width, initial-scale=1.0" />
     <title>BombIt</title>
     <style>
         /* Style to contain the canvas */
         #canvasContainer {
             width: 100%;
             display: flex;
             justify-content: center;

         }
     </style>
</head>
<body>
 <div id="canvasContainer" >
     <canvas id="myCanvas" width="1000" height="400"></canvas>
 </div>
 
 <div>
     <button id="clearButton">Clear</button>
     <label for="symmetryCheckbox">Enable Symmetry</label>
     <input type="checkbox" id="symmetryCheckbox" checked>
     <label for="mirrorPoints">Number of mirror points</label>
     <input type="number" id="mirrorPoints" value="9" min="1" max="99">
 
     <select id="brushSelect">
         <option value="9">FatCap</option>
         <option value="5">SkinnyCap</option>        
         <option value="3">SuperSkinnyCap</option>        
         <option value="splat1">splat1</option> 
         <option value="splat2">splat2</option>
         <option value="drip1">drip1</option>
         <option value="drip2">drip2</option>
         </select>
         <input type="color" id="colorPicker" value="#FFFF00">
 </div>
 
 
 <form action="https://formspree.io/f/mwplbjba" method="POST" enctype="multipart/form-data">
     <label for="email">Your email:</label>
     <input type="email" name="email" id="email" />
     <button type="submit">SendIt</button>
 </form>
 
 <!-- Add formspree stuff here -->
 
 
 <script>
     const brushImages = {
         drip1: "assets/brush-images/drip1.png",
         drip2: "assets/brush-images/drip2.png",
         splat1: "assets/brush-images/splat1.png",
         splat2: "assets/brush-images/splat2.png"
     };
 </script>
 
 <script>
     const imageBrushSize = 300;
    const imageBrushSpacing = 100;
     // Canvas Setup
     const canvas = document.getElementById('myCanvas');
     const ctx = canvas.getContext('2d');
     const canvasContainer = document.getElementById('canvasContainer');
     let canvasWidth = 1000;//default width
     let canvasHeight = 400;//changed the default height
     const originalAspectRatio = canvasWidth / canvasHeight;
     let isDrawing = false;    
     let lastX = 0;
     let lastY = 0;
     let isSymmetric = true; //enable by default
     let selectedColor = '#FFFF00'; // Default color is now bright yellow
     let selectedLineWidth = 9;//changed the default line width to fatcap
     let mirrorPoints = 9;//changed default to 9 mirror points
     let selectedBrushType = "line"; // Added a variable to keep track of the selected brush type
      let centerX = canvasWidth / 2;
      let lastImageX=0;
      let lastImageY=0;
     let centerY = canvasHeight / 2;    
 
     // Function to update the canvas size
     function updateCanvasSize() {
         const containerWidth = canvasContainer.offsetWidth;
         const newCanvasWidth = containerWidth;
         const newCanvasHeight = newCanvasWidth / originalAspectRatio;
 
         canvas.width = newCanvasWidth;
         canvas.height = newCanvasHeight;
         canvasWidth = newCanvasWidth;
         canvasHeight = newCanvasHeight;
         // Update the center after the size is updated
         centerX = canvasWidth / 2;
         centerY = canvasHeight / 2;//the center should also be updated
          // Redraw everything
          applyDrawingStyles();
         ctx.clearRect(0, 0, canvas.width, canvas.height);
     }
 
     // Call the function on load and on resize
     window.addEventListener('load', updateCanvasSize);
     window.addEventListener('resize', updateCanvasSize);
 
     // Apply changes to the canvas context
     function applyDrawingStyles() {
         ctx.strokeStyle = selectedColor;
         ctx.lineJoin = 'round';
         ctx.lineCap = 'round';
         ctx.lineWidth = selectedLineWidth;
     }
     // Function to draw splatter
     function drawSplatter(x, y) {
         if(brushImages[selectedBrushType]){return;}
         const splatterRadius = selectedLineWidth*2;
         const numPoints = 20;
 
         for (let i = 0; i < numPoints; i++) {
             const angle = Math.random() * 2 * Math.PI;
             const radius = Math.random() * splatterRadius;
             const splatterX = x + radius * Math.cos(angle);
             const splatterY = y + radius * Math.sin(angle);
 
             ctx.beginPath();            
             ctx.arc(splatterX, splatterY, 1, 0, 2 * Math.PI);
             ctx.fill();
         }
     }
     function drawDrip(x, y, length, angle) {
         if(brushImages[selectedBrushType]){return;}
         ctx.beginPath();
         ctx.moveTo(x, y);      
         // Calculate the end point of the drip based on length and angle
         const endX = x + length * Math.cos(angle);
         const endY = y + length * Math.sin(angle);        
     
         // Quadratic BÃ©zier curve control point
         const controlX = (x + endX) / 2 + (length / 2) * Math.cos(angle + Math.PI / 2);
         const controlY = (y + endY) / 2 + (length / 2) * Math.sin(angle + Math.PI / 2);
         
         ctx.quadraticCurveTo(controlX, controlY, endX, endY);
         ctx.stroke();
     }
     function drawDrips(x,y){
         if(brushImages[selectedBrushType]){return;}
         const numDrips = 3; // You can adjust the number of drips
         const dripLength = selectedLineWidth * 4 ; // Adjust the length of the drips
         const maxDripAngleVariation = Math.PI / 6; // Adjust the angle variation
 
         for (let i = 0; i < numDrips; i++) {
             const dripAngle = Math.PI / 2 + (Math.random() - 0.5) * maxDripAngleVariation;
             const dripStartX = x + (Math.random() - 0.5) * selectedLineWidth; // Randomly vary the starting point of the drips
             const dripStartY = y;
              // Change color for each drip
              ctx.strokeStyle = selectedColor;
              drawDrip(dripStartX, dripStartY, dripLength, dripAngle);
            
         }
     }
     function drawImageBrush(x, y, selectedImage) {
         ctx.drawImage(selectedImage, x - imageBrushSize / 2, y - imageBrushSize / 2, imageBrushSize, imageBrushSize);        
     }
    
     
     // Symmetry Checkbox
     const symmetryCheckbox = document.getElementById('symmetryCheckbox');
     
     // Number of mirror points input
     const mirrorPointsInput = document.getElementById('mirrorPoints');
     
     mirrorPointsInput.addEventListener('change', () => {
         mirrorPoints = parseInt(mirrorPointsInput.value);
         mirrorPoints = mirrorPoints > 99 ? 99 : mirrorPoints; //limit the amount of mirror points to 99
     });
     
     symmetryCheckbox.addEventListener('change', () => {
         isSymmetric = symmetryCheckbox.checked;
     });
 
     // Brush Selector
     const brushSelect = document.getElementById('brushSelect');
     brushSelect.addEventListener('change', () => {//function executed whenever you change the value of the select
         if(brushImages[brushSelect.value]){
             selectedBrushType = brushSelect.value;
             
         }else{//if it was a number selected make sure to update the selected line width
             selectedLineWidth = parseInt(brushSelect.value);
              selectedBrushType = "line";
         }
         applyDrawingStyles();
     });
 
         // Color Picker
     const colorPicker = document.getElementById('colorPicker');
     colorPicker.addEventListener('change', () => {
             selectedColor = colorPicker.value;
             applyDrawingStyles();
     });
 
         // Drawing Logic
         canvas.addEventListener('mousedown', (e) => {
             isDrawing = true;
              [lastX, lastY] = [e.offsetX, e.offsetY];
             
             if (selectedBrushType === "splatter" && !brushImages[selectedBrushType]) {
                 ctx.fillStyle = selectedColor; // Set the fill style for the splatter          
              }else if(selectedBrushType ==="drips" && !brushImages[selectedBrushType]){
                  ctx.strokeStyle = selectedColor;             
             }else if(brushImages[selectedBrushType]){
                
              }else{
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                 
                ctx.strokeStyle=selectedColor;
                 applyDrawingStyles();
               
              }
         });        
 
         canvas.addEventListener('mousemove', (e) => {
              if (!isDrawing) return;//if not drawing don't draw
              if(brushImages[selectedBrushType]){
                  const currentX = e.offsetX;
                  const currentY = e.offsetY;
                   const distanceMoved = Math.sqrt(
                       Math.pow(currentX - lastImageX, 2) + Math.pow(currentY - lastImageY, 2)
                   );
                  if(distanceMoved>=imageBrushSpacing){
                       const img = new Image();
                       img.src = brushImages[selectedBrushType];
                       img.onload = () => {
                           drawImageBrush(e.offsetX,e.offsetY, img); 
                           if (isSymmetric) {
                               drawSymmetricImage(e,img);
                           }
                           [lastImageX, lastImageY] = [e.offsetX, e.offsetY];
                       }
                     }                     
                 
                 
                 
                 return;
              }
             
             applyDrawingStyles();
             if(selectedBrushType === "splatter" ){
                 drawSplatter(e.offsetX,e.offsetY)
                  if (isSymmetric) {
                     const angleIncrement = (2 * Math.PI) / mirrorPoints;
                     const dx = e.offsetX - centerX;
                     const dy = e.offsetY - centerY; 
                     const baseAngle = Math.atan2(dy, dx);
                     const dist = Math.sqrt(dx * dx + dy * dy);
                     for (let i = 0; i < mirrorPoints; i++) {
                         const rotatedAngle = baseAngle + i * angleIncrement;
                         const rotatedX = centerX + dist * Math.cos(rotatedAngle);
                         const rotatedY = centerY + dist * Math.sin(rotatedAngle);
                         drawSplatter(rotatedX, rotatedY);
                        
                      }
                 }
             }else if(selectedBrushType ==="drips" ){
                 drawDrips(e.offsetX,e.offsetY)
                 if(isSymmetric){
                     const angleIncrement = (2 * Math.PI) / mirrorPoints;
                     const dx = e.offsetX - centerX;
                     const dy = e.offsetY - centerY; 
                     const baseAngle = Math.atan2(dy, dx);
                     const dist = Math.sqrt(dx * dx + dy * dy);
                     for (let i = 0; i < mirrorPoints; i++) {
                         const rotatedAngle = baseAngle + i * angleIncrement;
                         const rotatedX = centerX + dist * Math.cos(rotatedAngle);
                         const rotatedY = centerY + dist * Math.sin(rotatedAngle);
                         drawDrips(rotatedX,rotatedY)
                     }
                 }
             }else{
                  if (isSymmetric) {
                     const dx = e.offsetX - centerX;
                     const dy = e.offsetY - centerY;
                     const angleIncrement = (2 * Math.PI) / mirrorPoints;
                     const baseAngle = Math.atan2(dy, dx);
                     const dist = Math.sqrt(dx * dx + dy * dy);
                     const dxl = lastX - centerX;
                     const dyl = lastY - centerY;
                     const anglel = Math.atan2(dyl, dxl);
                     const distl = Math.sqrt(dxl * dxl + dyl * dyl);
                     for (let i = 0; i < mirrorPoints; i++) {
                         const rotatedAngle = baseAngle + i * angleIncrement;
                         const rotatedX = centerX + dist * Math.cos(rotatedAngle);
                         const rotatedY = centerY + dist * Math.sin(rotatedAngle);
                         const rotatedAnglel = anglel + i * angleIncrement;
                         const rotatedXl = centerX + distl * Math.cos(rotatedAnglel);
                         const rotatedYl = centerY + distl * Math.sin(rotatedAnglel);
                         ctx.beginPath();
                         ctx.moveTo(rotatedXl,rotatedYl)
                         ctx.lineTo(rotatedX, rotatedY);
                         ctx.stroke();
                     }
                 } else {
                     ctx.beginPath();
                     ctx.moveTo(lastX, lastY);
                     ctx.lineTo(e.offsetX, e.offsetY);
                     ctx.stroke();
                 }
             }
             [lastX, lastY] = [e.offsetX, e.offsetY];
         });
        function drawSymmetricImage(e,img){
          const angleIncrement = (2 * Math.PI) / mirrorPoints;
          const dx = e.offsetX - centerX;
          const dy = e.offsetY - centerY; 
          const baseAngle = Math.atan2(dy, dx);
          const dist = Math.sqrt(dx * dx + dy * dy);
          for (let i = 0; i < mirrorPoints; i++) {
              const rotatedAngle = baseAngle + i * angleIncrement;
              const rotatedX = centerX + dist * Math.cos(rotatedAngle);
              const rotatedY = centerY + dist * Math.sin(rotatedAngle);            
              drawImageBrush(rotatedX,rotatedY,img);
          }
         }
 
         canvas.addEventListener('mouseup', () => isDrawing = false);
         canvas.addEventListener('mouseout', () => isDrawing = false);
 
         // Clear Button
         const clearButton = document.getElementById('clearButton');
         clearButton.addEventListener('click', () => {           
             ctx.clearRect(0, 0, canvasWidth, canvasHeight);
              
         });
 
         //update the variables after full page load
         window.addEventListener('load', function() {
             mirrorPoints = parseInt(mirrorPointsInput.value);
             isSymmetric = symmetryCheckbox.checked;
              applyDrawingStyles();
         })
         brushSelect.value="9";
         //make sure that the initial selectedBrushType is line when the page loads       
         selectedBrushType="line"
        
         
     
 </script>
 </body>
 </html>