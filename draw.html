<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BombIt</title>
    <style>
        /* Style to contain the canvas */
        #canvasContainer {
            width: 100%;
            display: flex;
            justify-content: center;
            border: 5px solid white; /* White border around the canvas */


        }
    </style>
</head>
<body>
    <div id="canvasContainer">
        <canvas id="myCanvas" width="1000" height="400"></canvas>
    </div>
    
    <div>
        <button id="clearButton">Clear</button>
        <label for="symmetryCheckbox">Enable Symmetry</label>
        <input type="checkbox" id="symmetryCheckbox">
        <label for="mirrorPoints">Number of mirror points</label>
        <input type="number" id="mirrorPoints" value="1" min="1" max="99">

        <select id="brushSelect">
            <option value="3">SuperSkinnyCap</option>            
            <option value="5">SkinnyCap</option>
            <option value="9">FatCap</option>
            <option value="13">NewYorkCapFatCap</option>
            <option value="splatter">Splatters</option>
            <option value="drips">Drips</option>

        </select>
        <input type="color" id="colorPicker" value="#FFFF00">

        </div>
        <button id="downloadButton">Download</button>


    <form
    action="https://formspree.io/f/mwplbjba"
    method="POST"
    enctype="multipart/form-data"
    >
    <label for="email">Your email:</label>
    <input type="email" name="email" id="email" />
    <button type="submit">SendIt</button>
    </form>
    <!-- Add formspree stuff here -->
    <script>
        // Canvas Setup
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvasContainer');
        let canvasWidth = 1000;
        let canvasHeight = 400;//changed the default height
        const originalAspectRatio = canvasWidth / canvasHeight;
        let centerX = canvasWidth / 2;
        let centerY = canvasHeight / 2;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let isSymmetric = true; //enable by default
        let selectedColor = '#FFFF00'; // Default color is now bright yellow
        let selectedLineWidth = 9;//changed the default line width to fatcap
        let mirrorPoints = 9;//changed default to 9 mirror points
        let selectedBrushType = "line"; // Added a variable to keep track of the selected brush type

        // Function to update the canvas size
        function updateCanvasSize() {
            const containerWidth = canvasContainer.offsetWidth;
            const newCanvasWidth = containerWidth;
            const newCanvasHeight = newCanvasWidth / originalAspectRatio;

            canvas.width = newCanvasWidth;
            canvas.height = newCanvasHeight;
            canvasWidth = newCanvasWidth;
            canvasHeight = newCanvasHeight;
            // Update the center after the size is updated
            centerX = canvasWidth / 2;
            centerY = canvasHeight / 2;
             // Redraw everything
             applyDrawingStyles();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // Call the function on load and on resize
        window.addEventListener('load', updateCanvasSize);
        window.addEventListener('resize', updateCanvasSize);

        // Apply changes to the canvas context
        function applyDrawingStyles() {
            ctx.strokeStyle = selectedColor;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.lineWidth = selectedLineWidth;
        }
        // Function to draw splatter
        function drawSplatter(x, y) {
            const splatterRadius = selectedLineWidth*2;
            const numPoints = 20;

            for (let i = 0; i < numPoints; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const radius = Math.random() * splatterRadius;
                const splatterX = x + radius * Math.cos(angle);
                const splatterY = y + radius * Math.sin(angle);

                ctx.beginPath();            
                ctx.arc(splatterX, splatterY, 1, 0, 2 * Math.PI); 
                ctx.fill();
            }
        }
        function drawDrip(x, y, length, angle) {
            ctx.beginPath();
            ctx.moveTo(x, y);
        
            // Calculate the end point of the drip based on length and angle
            const endX = x + length * Math.cos(angle);
            const endY = y + length * Math.sin(angle);
        
            // Quadratic BÃ©zier curve control point
            const controlX = (x + endX) / 2 + (length / 2) * Math.cos(angle + Math.PI / 2);
            const controlY = (y + endY) / 2 + (length / 2) * Math.sin(angle + Math.PI / 2);
            
            ctx.quadraticCurveTo(controlX, controlY, endX, endY);
            ctx.stroke();
        }
        function drawDrips(x,y){
             const numDrips = 3; // You can adjust the number of drips
            const dripLength = selectedLineWidth * 4 ; // Adjust the length of the drips
            const maxDripAngleVariation = Math.PI / 6; // Adjust the angle variation

            for (let i = 0; i < numDrips; i++) {
                const dripAngle = Math.PI / 2 + (Math.random() - 0.5) * maxDripAngleVariation;
                const dripStartX = x + (Math.random() - 0.5) * selectedLineWidth; // Randomly vary the starting point of the drips
                const dripStartY = y;
                 // Change color for each drip
                 ctx.strokeStyle = selectedColor;
                 drawDrip(dripStartX, dripStartY, dripLength, dripAngle);
               
            }
        }
        
        // Symmetry Checkbox
        const symmetryCheckbox = document.getElementById('symmetryCheckbox');
        
        //Number of mirror points input
        const mirrorPointsInput = document.getElementById('mirrorPoints');
        
        mirrorPointsInput.addEventListener('change', () => {
            mirrorPoints = parseInt(mirrorPointsInput.value);
            mirrorPoints = mirrorPoints > 9 ? 9 : mirrorPoints; //limit the amount of mirror points to 9
        });
        
        symmetryCheckbox.addEventListener('change', () => {
            isSymmetric = symmetryCheckbox.checked;
        });

        // Brush Selector
        const brushSelect = document.getElementById('brushSelect');
        brushSelect.addEventListener('change', () => {
            selectedBrushType = "line"
            if(brushSelect.value === "splatter"){
                selectedBrushType = "splatter";
            }else if(brushSelect.value === "drips"){
                selectedBrushType = "drips";
                
            }else{
                selectedLineWidth = parseInt(brushSelect.value);
                brushSelect.value = "9" //make the fatcap selected by default
                 selectedBrushType = "line";
            }
            applyDrawingStyles();
        });

        // Color Picker
        const colorPicker = document.getElementById('colorPicker');
        colorPicker.addEventListener('change', () => {
            selectedColor = colorPicker.value;
              applyDrawingStyles();
        });

        // Drawing Logic
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
             [lastX, lastY] = [e.offsetX, e.offsetY];
             if (selectedBrushType === "splatter") {
                ctx.fillStyle = selectedColor; // Set the fill style for the splatter
             }else if(selectedBrushType ==="drips"){
                ctx.strokeStyle = selectedColor;
             }
             if(isSymmetric){
                 ctx.fillStyle = selectedColor;
             }
        });

        canvas.addEventListener('mousemove', (e) => {
             if (!isDrawing) return;
            applyDrawingStyles();
            if(selectedBrushType === "splatter"){
                drawSplatter(e.offsetX,e.offsetY)
                 if (isSymmetric) {
                    const angleIncrement = (2 * Math.PI) / mirrorPoints;
                    const dx = e.offsetX - centerX;
                    const dy = e.offsetY - centerY; 
                    const baseAngle = Math.atan2(dy, dx);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    for (let i = 0; i < mirrorPoints; i++) {
                        const rotatedAngle = baseAngle + i * angleIncrement;
                        const rotatedX = centerX + dist * Math.cos(rotatedAngle);
                        const rotatedY = centerY + dist * Math.sin(rotatedAngle);
                        drawSplatter(rotatedX, rotatedY);
                       
                     }
                }
            }else if(selectedBrushType ==="drips"){
                drawDrips(e.offsetX,e.offsetY)
                if(isSymmetric){
                    const angleIncrement = (2 * Math.PI) / mirrorPoints;
                    const dx = e.offsetX - centerX;
                    const dy = e.offsetY - centerY; 
                    const baseAngle = Math.atan2(dy, dx);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    for (let i = 0; i < mirrorPoints; i++) {
                        const rotatedAngle = baseAngle + i * angleIncrement;
                        const rotatedX = centerX + dist * Math.cos(rotatedAngle);
                        const rotatedY = centerY + dist * Math.sin(rotatedAngle);
                        drawDrips(rotatedX,rotatedY)
                    }
                }
            }else{
                 if (isSymmetric) {
                    const dx = e.offsetX - centerX;
                    const dy = e.offsetY - centerY;
                    const angleIncrement = (2 * Math.PI) / mirrorPoints;
                    const baseAngle = Math.atan2(dy, dx);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const dxl = lastX - centerX;
                    const dyl = lastY - centerY;
                    const anglel = Math.atan2(dyl, dxl);
                    const distl = Math.sqrt(dxl * dxl + dyl * dyl);
                    for (let i = 0; i < mirrorPoints; i++) {
                        const rotatedAngle = baseAngle + i * angleIncrement;
                        const rotatedX = centerX + dist * Math.cos(rotatedAngle);
                        const rotatedY = centerY + dist * Math.sin(rotatedAngle);
                        const rotatedAnglel = anglel + i * angleIncrement;
                        const rotatedXl = centerX + distl * Math.cos(rotatedAnglel);
                        const rotatedYl = centerY + distl * Math.sin(rotatedAnglel);
                        ctx.beginPath();
                        ctx.moveTo(rotatedXl,rotatedYl)
                        ctx.lineTo(rotatedX, rotatedY);
                        ctx.stroke();
                    }
                } else {
                    ctx.beginPath();
                    ctx.moveTo(lastX, lastY);
                    ctx.lineTo(e.offsetX, e.offsetY);
                    ctx.stroke();
                }
            }
            [lastX, lastY] = [e.offsetX, e.offsetY];
        });

        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseout', () => isDrawing = false);

        // Clear Button
        const clearButton = document.getElementById('clearButton');
        clearButton.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        });

        
        mirrorPointsInput.value=9;//update the input field to 9
        //update the variable
        isSymmetric = true;//set the default value of isSymmetric to true
        symmetryCheckbox.checked=true;//update the checkbox to be checked

        //update the variables after full page load
        window.addEventListener('load', function() {
            mirrorPoints = parseInt(mirrorPointsInput.value);
            isSymmetric = symmetryCheckbox.checked;
             applyDrawingStyles();
        })
        brushSelect.value="9"
        //make sure that the initial selectedBrushType is line when the page loads
        selectedBrushType="line"
        
    </script>
</body>
</html>